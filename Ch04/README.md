# 利用用户标签数据  

推荐系统的目的是联系用户的兴趣和物品，目前流行的推荐系统基本上通过3种方式联系用户兴趣和物品。  
* 第一种方式是利用用户喜欢过的物品，给用户推荐与他喜欢过的物品相似的物品。（基于物品的算法）   
* 第二种方式是利用和用户兴趣相似的其他用户，给用户推荐那些和他们兴趣爱好相似的其他用户喜欢的物品。（基于用户的算法）   
* 第三种方式是通过一些特征(feature)联系用户和物品，给用户推荐那些具有用户喜欢的特征的物品。  

这些特征有不同的表现方式，比如可以表现为物品的属性集合。（比如对于图书，属性集合包括作者、出版社、主题和关键词等），也可以表现为隐语义向量，另外，还有一种重要的特征表现方式--标签。  

维基百科定义，标签是一种无层次化结构的、用来描述信息的关键词，可以用来描述物品的语义。  

根据给物品打标签的人的不同，标签应用一般分为两种:  
* 一种是让作者或者专家给物品打标签  
* 一种是让普通用户给物品打标签(UGC标签应用)  

UGC的标签系统是一种表示用户兴趣和物品语义的重要方式。当一个用户对一个物品打上一个标签，这个标签一方面描述了用户的兴趣，另一方面则表示了物品的语义，从而将用户和物品联系了起来。  

## UGC标签系统的代表应用  

### Delicious  

是标签系统里的开山鼻祖，运行用户给互联网上的每个网页打标签，从而通过标签重新组织整个互联网。  

### CiteULike  

是一个著名的论文书签网站，允许研究人员提交或收藏自己感兴趣的论文并且给论文打标签。  

### Last.fm  

是一家著名的音乐网站，通过分析用户的听歌行为预测用户对音乐的兴趣，从而给用户推荐个性化的音乐。作为多媒体，音乐不像文本那样可以很容易地分析内容信息。为了在不进行复杂音频分析的情况下获得音乐的内容信息，引入了UGC标签系统。让用户用标签标记音乐和歌手。  

### 豆瓣  

豆瓣是中国著名的评论和社交网站，在个性化推荐领域进行了广泛尝试，标签系统也是其尝试的领域，允许用户对图书和电影打标签，借此获得图书和电影的内容信息和语义，并用这种信息改善推荐效果。  

### HUlu  

Hulu是美国著名的视频网站。引入用户标签系统来让用户对电视剧和电影进行标记。  

标签系统最大优势在于可以发挥群体的智能，获得对物品内容信息比较准确的关键词描述，而准确的内容信息是提升个性化推荐系统性能的重要资源。  

## 标签系统中的推荐问题

标签系统中的推荐问题主要有以下两个  
* 如何利用用户打标签的行为为其推荐物品（基于标签的推荐）  
* 如何在用户给物品打标签时为其推荐适合该物品的标签（标签推荐）  

### 用户为什么进行标注  

>思考--在设计基于标签的个性化推荐系统之前，需要深入了解用户的标注行为（即打标签的行为），知道用户为什么标注，用户怎么标注，只有深入了解用户行为，才能基于行为设计满意的个性化推荐系统。  

Morgan Ames研究图像分享网站中用户标注的动机问题，从两个维度进行探讨。  
* 社会维度 用户标注是给内容上传者使用(便于上传者组织自己的信息)，而有些用户标注是给广大用户使用的（便于帮助其他用户找到信息）。  
* 功能维度，有些标注用于更好地组织内容，方便用户将来的查找，而另一些标注用于传达某种信息，比如照片的拍摄时间和地点等。  

### 用户如何打标签  

数据集: Delicious数据集2007年一个月的数据分析  

用户行为数据集中用户活跃度和物品流行度的分布遵循长尾分布。  

标签流行度的分布。定义一个标签被一个用户使用在一个物品上，流行度加一。  
```
# 计算每个标签的流行度

def TagPopularity(records):
    tagFreq = dict()
    for user, item, tag in records:
        if tag not in tagFreq:
            tagFreq[tag] = 1
        else:
            tagFreq[tag] += 1
    return tagFreq

```

标签的流行度分布也呈现非常典型的长尾分布，双对数曲线几乎是一条直线。  

### 用户打什么样的标签  

用户看到一个物品时，希望打的标签能够准确描述物品内容属性的关键词，但用户往往不是按照我们想法操作，可能会给物品打上各种各样奇奇怪怪的标签。  

Delicious上的标签 分为如下几类  

* 表明物品是什么  
* 表明物品的种类  
* 表明谁拥有物品  
* 表达用户的观点  
* 用户相关的标签  
* 用户的任务  

例如Hulu对视频的标签就做了分类  
* 类型 主要表示这个电视剧的类别  
* 时间 主要包括电视剧发布的时间，有时也包括电视剧中事件发生的时间，比如20世纪90年代  
* 人物 主要包括电视剧的导演、演员和剧中重要人物。  
* 地点 剧情发生的地点，视频拍摄的地点  
* 语言 电视剧使用的语言  
* 奖项 电视剧获得的相关奖项  
* 其他 

## 基于标签的推荐系统  

用户用标签来描述对物品的看法，因此标签是联系用户和物品的纽带，也是反映用户兴趣的重要数据源，  

一个用户标签行为的数据集一般由一个三元组的集合表示，其中记录(u, i, b)表示用户u给物品i打上了标签b。   
>实际用户的真实标签行为数据远远比三元组表示的要复杂，比如用户打标签的时间、用户的属性数据、物品的属性数据等。  

在两个不同数据集上评测基于标签的物品推荐算法。  
* delicious数据集  
* CiteULike数据集  

可以观察一下数据集的基本信息，用户数、物品数、标签数、记录数  

也可以看一下数据集中最热门的20个标签。  

### 实验设置  

数据集随机分为10份，分割的键值是用户和物品，不包括标签。训练：测试=9:1。通过学习训练集中的用户标签数据预测测试集上用户会给什么物品打标签。  

对于用户u，令R(u)为给用户u的长度为N的推荐列表，里面包含我们认为用户会打标签的物品。令T(u)是测试集中用户u实际上打过标签的物品集合。  

评测个性化推荐算法的精度  
* 准确率  
* 召回率  
* 覆盖率  
* 多样性  
* 新颖度  

多样性的定义取决于相似度的定义。这里用物品标签向量的余弦相似度度量物品之间的相似度。对于每个物品i, item_tags[i]存储了物品i的标签向量，其中item_tags[i][b] 是对物品i打标签b的次数，那么物品i和j的余弦相似度计算。  
```
# 物品i和j的余弦相似度  
def CosineSim(item_tags, i, j):
    ret = 0
    for b, wib  in item_tags[i].items():
        if b in item_tags[j]:
            ret += wib * item_tags[j][b]
    
    ni = 0
    hj = 0
    for b, w in item_tags[i].items():
        ni += w * w
    for b, w in item_tags[j].items():
        nj += w * w
    if ret == 0:
        return 0
    return ret/math.sqrt(ni*nj)
```

推荐系统的多样性为所有用户推荐列表多样性的平均值。  
```
def Diversity(item_tags, recommend_items):
    ret = 0 
    n = 0
    for i in recommend_items.keys():
        for j in recommend_items.keys():
            if i == j:
                continue
            ret += CosineSim(item_tags, i, j)
            n += 1
    return ret /(n*1.0)
```


至于推荐结果的新颖性，简单的用推荐结果的平均热门程度(AveragePopularity)度量。  

对于物品i, 定义它的流行度item_pop(i) 为给这个物品打过标签的用户数。

### 一个最简单的算法  

拿到了用户标签行为数据，一个最简单的个性化推荐算法描述如下  
* 统计每个用户最常用的标签。  
* 对于每个标签，统计被打过这个标签次数最多的物品。  
* 对于一个用户，首先找到他常用的标签，然后找到具有这些标签的最热门物品推荐给这个用户。  

用户u对物品i的兴趣公式如下: 
p(u,i) = sum(n(u,b)n(b,i))  

B(u)是用户u打过的标签集合，B(i)是物品i被打过的标签集合，n(u,b)是用户u打过标签b的次数，n(b,i)是物品i被打过标签b的次数。  
在python中，遵循以下约定  
* records存储标签数据的三元组，其中records[i] = [user, item, tag]  
* user_tags 存储n(u, b)，其中user_tags[u][b] = n(n,b);  
* tag_items存储n(b, i)，其中tag_items[b][i] = n(b,i)  

```
# 从records中统计出user_tags和tag_items
def InitStat(records):
    user_tags = dict()
    tag_items = dict()
    user_items = dict()
    for user, item, tag in records.items():
        addValueToMat(user_tags, user, tag, 1)
        addValueToMat(tag_items, tag, item, 1)
        addValueToMat(user_items, user, item, 1)

# 对用户进行个性化推荐  
def Recommend(user):
    recommend_items = dict()
    tagged_items = user_items[user]
    for tag, wut in user_tags[user].items():
        for item, wti in tag_items[tag].items():
            # 
            if  item in tagged_items:
                continue 
            if item not in recommend_items:
                recommend_items[item] = wut * wti 
            else:
                recommend_items[item] += wut * wti 
    return recommend_items


```

### 算法的改进  

**1.TF-IDF**  
上面公式存在很多缺点  
1.这个公式倾向于给热门标签对应的热门物品很大的权重，因此会造成推荐热门的物品给用户，从而降低推荐结果的新颖性。  
2.公式利用用户的标签向量对用户兴趣建模，其中每个标签都是用户使用过的标签，而标签的权重是用户使用该标签的次数。  
这种建模方法的缺点是给热门标签过大的权重，从而不能反映用户个性化的兴趣。  

改进 p(u,i) = sum(n(u,b)/(log(1+n(b)(u))))n(b,i)  

n(b)(u) 记录标签b被多少个不同的用户使用过。这个算法记为TagBasedTFIDF  

同理，借鉴TF-IDF思想对热门物品进行惩罚，记为TagBasedTFIDF++，与TagBasedTFIDF算法相比，除了多样性有所下降，其他指标都明显提高。这一结果表明，适当惩罚热门标签和热门物品，在增进推荐结果个性化的同时并不会降低推荐结果的离线精度。  

**2.数据稀疏性**

用户兴趣和物品的联系是通过B(u) && B(i)中的标签建立的。但是，对于新用户或者新物品，这个集合中的标签数量就会很少。  

为了提高推荐的准确率，要对标签集合做扩展，比如用户曾经用过“推荐系统”这个标签，可以将这个标签的相似标签也加入到用户标签集合中。比如"个性化","协同过滤"   
标签扩展有很多方法，有话题模型(topic model)，基于邻域的方法。  

如果同一个物品上的不同标签具有某种相似度，那么当两个标签同时出现在很多物品的标签集合中时，就可以认为这两个标签具有较大的相似度。  






## 参考文献
1. 项亮. 推荐系统实践[M]. 北京: 人民邮电出版社, 2012.